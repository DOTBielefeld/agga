import math
import numpy as np


def calc_area_for_front(front, ref):
    # calc the areas spanned by the points on the front
    w = {}
    for i in range(len(front)):
        for j in range(len(front)):
            if i <= j:
                if j + 1 != len(front):
                    height = front[j][0] - front[j + 1][0]
                else:
                    height = front[j][0] - ref[0][0]

                if i - 1 != -1:
                    width = front[i][1] - front[i - 1][1]
                else:
                    width = front[i][1] - ref[0][1]

                if i + 1 not in w.keys():
                    w[i + 1] = {}

                w[i + 1][j + 1] = height * width

                if height * width < 0:
                    raise Exception("Got negative area. Should not happen")
    return w


def conf_area_map(front, conf_traj):
    # map the confs to their area numbers
    pc = {}
    for point in range(len(front)):
        for conf, traj in conf_traj.items():

            if point + 1 not in pc.keys():
                pc[point + 1] = {}

            if front[point] in traj:
                pc[point + 1][conf] = 1
            else:
                pc[point + 1][conf] = 0
    return pc


def conf_t_active(conf_traj, t_max):
    # compute a map between timesteps and points generated by a conf
    pc = {}
    for conf, traj in conf_traj.items():
        for p in range(len(traj)):

            if conf not in pc:
                pc[conf] = {}
            pc[conf][p + 1] = {t: 1 if math.ceil(traj[p][0]) == t else 0 for t in range(t_max)}
    return pc


def get_number_points_conf(pc, conf_ids):
    # compute how often a conf is on the pareto front
    n_p_confs = {k: 0 for k in conf_ids}
    for k in pc.values():
        for kk in k.values():
            for c, s in kk.items():
                if s == 1:
                    n_p_confs[c] = n_p_confs[c] + 1
    return n_p_confs


def find_dominating_indices_numpy(points, index):
    other_points = np.concatenate([points[:index], points[index+1:]])
    dominance = np.all(other_points >= points[index], axis=1) & np.any(other_points > points[index], axis=1)
    dominating_indices = np.where(dominance)[0]
    dominating_indices = [i + 1 if i < index else i + 2 for i in dominating_indices]
    return dominating_indices

def dom_points(front):
    points = np.array(front)
    dm = {i+1: find_dominating_indices_numpy(points, i) for i in range(len(points))}
    return dm


def pre_comp_area(front, ref):
    area_c = {}
    for conf, points in front.items():
        area_per_timestep = {}

        if len(points) != 0:
            points = [[0, ref]] + points + [[ref, points[-1][1]]]

            # if points same second step we take the best
            rounded_data = {}
            for time, value in points:
                rounded_time = math.ceil(time)
                rounded_data[rounded_time] = [time, value]

            points = list(rounded_data.values())

            for i in range(len(points) - 1):
                t1, q1 = points[i]

                t2, _ = points[i + 1]

                for t in range(math.ceil(t1), math.ceil(t2)):
                    area_per_timestep[t] = (ref - q1)

            area_c[conf] = area_per_timestep
        else:
            area_c[conf] = {t:0 for t in range(ref)}
    return area_c